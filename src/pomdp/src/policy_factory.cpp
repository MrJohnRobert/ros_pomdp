/**
 * @file
 *
 *
 *
 * @date Aug 10, 2013
 * @author B. Adkins
 */

#include <boost/filesystem/path.hpp>
#include <boost/units/detail/utility.hpp>

#include "policy_factory.h"
#include "feature_space.h"

#include "map_policy.h"
#include "alpha_policy.h"
#include "multinomial_policy.h"

namespace pomdp
{
/**
 * Polymorphically initializes a Policy from a config file.
 *
 * Isolates implementation from header. This avoids re-compiling files that use policy_factory.h and avoids circular
 * includes in Policies that themselves use the PolicyFactory.
 */
shared_ptr<Policy> PolicyFactory::loadFromFileImpl(const std::string& path,
                                                   shared_ptr<const FeatureSpace> state_space,
                                                   shared_ptr<const FeatureSpace> action_space)
{
  shared_ptr<Policy> policy_new;

  // Parse file path.
  boost::filesystem::path boost_path(path);
  std::string stem = boost_path.stem().string();
  std::string ext = boost_path.extension().string();

  if(ext == "")
  {
    ROS_ERROR("Extension needed for policy file '%s'", stem.c_str());
    return shared_ptr<Policy>();
  }

  // FeatureSpaces are mandatory. (name:number mapping inside is optional)
  if(!state_space)
  {
    ROS_ERROR("State space required to initialize Policy!");
    return shared_ptr<Policy>();
  }
  if(!action_space)
  {
    ROS_ERROR("Action space required to initialize Policy!");
    return shared_ptr<Policy>();
  }

  //
  // The following code could easily be autogenerated from comments in *_policy.h files and/or a list of extensions.
  //
  if(ext == ".map_policy" || ext == ".mdp_policy")
    policy_new.reset(new MapPolicy());
  else if(ext == ".alpha" || ext == ".a_policy" || ext == ".alpha_policy")
    policy_new.reset(new AlphaPolicy());
  else if(ext == ".mn_mdp_policy")
    policy_new.reset(new MultinomialMDPPolicy());
  else if(ext == ".mn_pomdp_policy")
    policy_new.reset(new MultinomialPOMDPPolicy());
  // Developers: insert new policy classes here.
  else
  {
    ROS_ERROR("No matching policy type for extension '%s' of file '%s'.", ext.c_str(), stem.c_str());
    return shared_ptr<Policy>();
  }
  ROS_INFO("Reading policy file '%s'...", path.c_str());

  // Assign pretty printers (the loadFile function may try to use them, if they're not NULL).
  policy_new->setActionSpace(action_space);
  ROS_INFO_STREAM("...using action space: " << *action_space);

  // Assign state space.
  policy_new->setStateSpace(state_space);
  ROS_INFO_STREAM("...using state space: " << *state_space); // Verified not empty above.

  // Finally load the policy from the config file.
  if(!policy_new->loadFromFile(path))
    return shared_ptr<Policy>();
  policy_new->setName(stem);

  ROS_INFO("...as %s named '%s'.", boost::units::detail::demangle(typeid(*policy_new).name()).c_str(),
           policy_new->getName().c_str());

  return policy_new;
}

} /* namespace pomdp */

